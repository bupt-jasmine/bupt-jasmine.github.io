---
title: "浅谈 C++ 的 CRTP"
collection: cpp
permalink: /cpp/cpp-crtp
excerpt: '介绍 C++ 中的 CRTP 设计模式及其应用场景'
date: 2025-12-03
---

在阅读项目的代码过程中，遇到了一种设计模式，起初并不熟悉，后来查阅资料后了解到它被称为 CRTP，所以学习并记录一下相关内容。

---

## 什么是 CRTP？
CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是一种 C++ 编程技术，它允许类通过模板参数继承自其自身的派生类。这种模式常用于静态多态性和代码复用。

---

## CRTP 的基本结构
CRTP 的基本结构如下：
```cpp
template <typename Derived>
class Base {
public:
    void interface() {
        // 调用派生类的方法
        static_cast<Derived*>(this)->implementation();
    }
};
class Derived : public Base<Derived> {
public:
    void implementation() {
        // 派生类的具体实现
    }
};
```
在这个例子中，`Base` 类是一个模板类，它接受一个类型参数 `Derived`。`Derived` 类继承自 `Base<Derived>`，从而实现了 CRTP。

---

## 为什么可以这样写？

这种设计利用了 C++ 的模板机制，使得基类可以访问派生类的成员函数和数据成员。通过 `static_cast<Derived*>(this)`，基类可以将 `this` 指针转换为派生类类型，从而调用派生类的方法。

这样做的好处是可以在编译时实现多态性，而不需要使用虚函数，从而避免了运行时的开销。同时还可以检查派生类是否实现了所需的方法。

---

## CRTP 的用途
1. **静态多态性**：CRTP 允许在编译时决定调用哪个方法，从而避免了运行时的虚函数开销。
2. **代码复用**：通过将通用功能放在基类中，派生类可以复用这些功能，而无需重复代码。
3. **类型安全**：CRTP 提供了一种类型安全的方式来实现多态性，因为类型检查在编译时进行。

---

## 那么什么时候使用 CRTP 呢？

CRTP 适用于以下场景：
- 需要在编译时实现多态性，而不希望引入虚函数开销的场景。
- 需要在多个类之间共享通用功能的场景。
- 需要实现静态接口检查的场景。

一般来说， CRTP 需要明确知道指针的具体类型时使用。如果不确定类型，或者需要在运行时决定类型，则应考虑使用传统的继承和虚函数机制。