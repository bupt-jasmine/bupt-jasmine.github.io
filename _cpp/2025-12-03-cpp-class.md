---
title: "浅谈 C++ 类"
collection: cpp
permalink: /cpp/cpp-class
excerpt: '浅谈 C++ 中的类'
date: 2025-12-02
---

## class 和 struct 有什么区别？

在 C++ 编程中，class 和 struct 都是用于定义用户自定义类型的关键字。它们之间的唯一差别在于默认的访问控制权限。struct 的成员默认是 public，而 class 的成员默认是 private。

## 一个空的 class 会占用多少内存呢？

根据 C++ 标准，一个空的 class 类型至少占用 1 个字节的内存。这是为了确保每个对象都有一个唯一的地址，即使它不包含任何数据成员。

```cpp
#include <iostream>
class EmptyClass {};
int main() {
    std::cout << "Size of EmptyClass: " << sizeof(EmptyClass) << " byte(s)" << std::endl;
    return 0;
}
```

编译运行之后应该是输出： `Size of EmptyClass: 1 byte(s)`

---

## 关于 class 的内存对齐

C++ 中的类对象在内存中通常会进行对齐，以提高访问效率。对齐的规则取决于类的成员类型及其排列顺序。编译器会根据成员的类型和对齐要求，在类对象中插入填充字节（padding），以确保每个成员都按照其对齐要求存储。

例如，考虑以下类定义：

```cpp
#include <iostream>
class MyClass {
    char a;      // 1 byte
    // 3 bytes padding
    int b;       // 4 bytes
    double c;    // 8 bytes
};
int main() {
    std::cout << "Size of MyClass: " << sizeof(MyClass) << " byte(s)" << std::endl;
    return 0;
}
```

输出结果应该是 16 字节，而不是简单的 13 字节（1 + 4 + 8），这是因为编译器在 `char a` 后面插入了 3 个填充字节，以确保 `int b` 按照 4 字节对齐存储。

---

## class 继承问题

在 C++ 中，类的继承也会影响内存布局。派生类对象的内存布局通常包括基类的成员以及派生类自己的成员。编译器会根据继承关系和成员类型进行适当的对齐和填充。

```cpp
#include <iostream>
class Base {
    char a;      // 1 byte
    // 3 bytes padding
    int b;       // 4 bytes
};

class Derived : public Base {
    double c;    // 8 bytes
};
int main() {
    std::cout << "Size of Derived: " << sizeof(Derived) << " byte(s)" << std::endl;
    return 0;
}
```
在这个例子中，`Derived` 类继承自 `Base` 类。`Derived` 类的对象大小将包括 `Base` 类的成员以及 `Derived` 类自己的成员。输出结果应该是 16 字节（8 字节的 `Base` 对象加上 8 字节的 `double c`）。

### std::shared_from_this

`std::shared_from_this` 是 C++11 引入的一个标准库特性，它允许类的成员函数获取指向当前对象的 `std::shared_ptr`。这对于需要在类的成员函数中共享当前对象的所有权时非常有用。

要使用 `std::shared_from_this`，类需要继承自 `std::enable_shared_from_this`，并且对象必须通过 `std::shared_ptr` 创建。以下是一个简单的示例：

```cpp
#include <iostream>
#include <memory>
class MyClass : public std::enable_shared_from_this<MyClass> {
public:
    std::shared_ptr<MyClass> getSharedPtr() {
        return shared_from_this();
    }
    void show() {
        std::cout << "MyClass instance at: " << this << std::endl;
    }
};
int main() {
    std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
    obj->show();

    std::shared_ptr<MyClass> sharedPtr = obj->getSharedPtr();
    sharedPtr->show();

    std::cout << "Use count: " << sharedPtr.use_count() << std::endl; // 输出 2
    return 0;
}
```
在这个例子中，`MyClass` 继承自 `std::enable_shared_from_this<MyClass>`，并实现了一个成员函数 `getSharedPtr`，它返回一个指向当前对象的 `std::shared_ptr`。在 `main` 函数中，我们通过 `std::make_shared` 创建了一个 `MyClass` 对象，并通过 `getSharedPtr` 获取了另一个共享指针。最后，我们打印了共享指针的引用计数，显示为 2，表示有两个 `std::shared_ptr` 实例共享同一个对象的所有权。

### 菱形继承问题

菱形继承（Diamond Inheritance）是指一个类同时继承自两个派生类，而这两个派生类又都继承自同一个基类。这种继承结构会导致基类的成员在派生类中出现多份拷贝，从而引发二义性和资源浪费等问题。

```cpp
#include <iostream>
class Base {
public:
    void show() {
        std::cout << "Base class show function" << std::endl;
    }
private:
    int baseData;
};

class Derived1 : public Base {
private:
    int derived1Data;
};

class Derived2 : public Base {
private:
    int derived2Data;
};

class FinalDerived : public Derived1, public Derived2 {
public:
    void display() {
        // show(); // 这将引发二义性错误
        Derived1::show(); // 需要指定调用哪个基类的方法
        Derived2::show();
    }
};
int main() {
    FinalDerived obj;
    obj.display();
    return 0;
}
```

在这个例子中，`FinalDerived` 类同时继承自 `Derived1` 和 `Derived2`，而这两个类又都继承自 `Base` 类。当我们尝试调用 `show` 方法时，会引发二义性错误，因为编译器无法确定调用的是 `Derived1` 还是 `Derived2` 中的 `Base` 部分的 `show` 方法。

同时，`Derived1` 和 `Derived2` 各自拥有一份 `Base` 类的成员数据，这会导致内存浪费。

### 解决菱形继承问题

为了解决菱形继承问题，C++ 提供了虚继承（Virtual Inheritance）机制。通过使用虚继承，派生类只会共享一个基类的实例，从而避免了二义性和资源浪费的问题。

```cpp
#include <iostream>
class Base {
public:
    void show() {
        std::cout << "Base class show function" << std::endl;
    }
private:
    int baseData;
};

class Derived1 : virtual public Base {
private:
    int derived1Data;
};

class Derived2 : virtual public Base {
private:
    int derived2Data;
};

class FinalDerived : public Derived1, public Derived2 {
public:
    void display() {
        show(); // 现在没有二义性，可以直接调用
    }
};
int main() {
    FinalDerived obj;
    obj.display();
    return 0;
}
```
在这个修改后的例子中，`Derived1` 和 `Derived2` 都通过 `virtual` 关键字虚继承自 `Base` 类。这样，`FinalDerived` 类中只会有一个 `Base` 类的实例，从而解决了二义性问题。现在，我们可以直接调用 `show` 方法，而不需要指定调用哪个基类的方法。

此外，虚继承还避免了基类成员的重复存储，从而节省了内存空间。

---

## 虚函数

虚函数是 C++ 中实现多态性的一种机制。通过在基类中声明虚函数，派生类可以重写这些函数，从而在运行时根据对象的实际类型调用相应的函数实现。

```cpp
#include <iostream>
class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
    virtual ~Base() {} // 虚析构函数，确保派生类对象正确销毁
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};
int main() {
    Base* basePtr = new Derived();
    basePtr->show(); // 输出 "Derived class show function"
    delete basePtr; // 正确调用 Derived 的析构函数
    return 0;
}
```
在这个例子中，`Base` 类中声明了一个虚函数 `show`。`Derived` 类重写了这个函数。在 `main` 函数中，我们通过基类指针 `basePtr` 指向一个派生类对象。当调用 `show` 方法时，实际调用的是 `Derived` 类中的实现，实现了运行时多态性。

对于 `std::shared_ptr` 包装的对象，可以通过 `reinterpret_pointer_cast` 来转换为基类指针，从而调用虚函数：

```cpp
#include <iostream>
#include <memory>
class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};
int main() {
    std::shared_ptr<Base> basePtr = std::make_shared<Derived>();
    auto derivedPtr = std::reinterpret_pointer_cast<Derived>(basePtr);
    derivedPtr->show(); // 输出 "Derived class show function"
    return 0;
}
```

---

## 内存布局与虚函数表机制

在 C++ 中，类的内存布局受到成员变量、继承关系以及虚函数等因素的影响。理解这些因素对于编写高效的 C++ 代码非常重要。

### 成员变量的内存布局

类的成员变量按照其声明顺序存储在内存中，但编译器可能会插入填充字节以满足对齐要求。对齐要求通常取决于成员变量的类型。例如，`int` 类型通常需要 4 字节对齐，而 `double` 类型通常需要 8 字节对齐。

### 继承关系的内存布局

在继承关系中，派生类对象的内存布局通常包括基类的成员以及派生类自己的成员。编译器会根据继承关系和成员类型进行适当的对齐和填充。

### 虚函数表机制

当类中包含虚函数时，编译器会为该类生成一个虚函数表（vtable）。虚函数表是一个指针数组，存储了类的虚函数的地址。每个包含虚函数的类对象都会有一个指向其虚函数表的指针，通常称为虚指针（vptr）。

虚函数指针位于 this 指针指向的对象内存布局的起始位置，通常是对象的第一个成员。这使得在调用虚函数时，编译器可以通过 this 指针快速访问虚函数表，从而实现动态绑定。

具体可以通过代码验证
```cpp
#include <iostream>
class Base {
public:
    virtual void show() {
        std::cout << "Base class show function" << std::endl;
    }
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived class show function" << std::endl;
    }
};

int main() {
    Derived obj;
    Base* basePtr = &obj;

    std::cout << "Address of obj: " << &obj << std::endl;
    std::cout << "Address of basePtr: " << basePtr << std::endl;

    // 获取虚指针地址
    void** vptr = *(void***)&obj;
    std::cout << "Address of vptr: " << vptr << std::endl;

    // 通过虚函数表获取虚函数
    typedef void (*FuncPtr)(Base*);
    FuncPtr func = (FuncPtr)vptr[0];
    func(basePtr);

    return 0;
}
```
在这个例子中，我们定义了一个基类 `Base` 和一个派生类 `Derived`，它们都包含一个虚函数 `show`。在 `main` 函数中，我们创建了一个 `Derived` 类的对象 `obj`，并通过基类指针 `basePtr` 指向它。

我们通过类型转换获取了对象的虚指针 `vptr`，并打印了它的地址。然后，我们从虚函数表中获取了第一个虚函数的地址，并通过函数指针调用了该虚函数，实现了动态绑定。

虚函数表里的虚函数按照声明顺序存储，调用时通过虚指针访问对应的函数地址，从而实现多态。如果是多层继承，比如 C 继承 B，B 继承 A，都重写了相同的虚函数，那么在具体的派生类的虚函数表中，会覆盖掉继承的虚函数表中对应的虚函数表项。

---

## C++ 单例

在实际项目中，基本都会有使用到单例模式的场景。

现在 C++ 中，实现一个安全的单例的方式已经非常简单了。

```cpp
#include <iostream>
class Singleton {
public:
    static Singleton* Instance() {
        static Singleton instance;
        return &instance;
    }
private:
    Singleton() {
        std::cout << "Singleton constructor called" << std::endl;
    }
    ~Singleton() {
        std::cout << "Singleton destructor called" << std::endl;
    }
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};
int main() {
    Singleton* singleton1 = Singleton::Instance();
    Singleton* singleton2 = Singleton::Instance();

    std::cout << "singleton1 address: " << singleton1 << std::endl;
    std::cout << "singleton2 address: " << singleton2 << std::endl;

    return 0;
}
```
在这个例子中，`Singleton` 类通过一个静态成员函数 `Instance` 实现单例模式。`Instance` 函数内部定义了一个静态局部变量 `instance`，该变量在第一次调用时被创建，并在程序结束时自动销毁。由于 C++11 标准保证了静态局部变量的初始化是线程安全的，因此这种实现方式是线程安全的。
