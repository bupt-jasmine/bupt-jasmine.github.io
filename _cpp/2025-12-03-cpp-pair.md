---
title: "浅谈 std::pair 内存优化"
collection: cpp
permalink: /cpp/cpp-pair
excerpt: '介绍如何通过偏特化 std::pair 来优化内存使用'
date: 2025-12-03
---

`std::pair` 是 C++ 标准库中一个非常有用的模板类，用于将两个数据项组合成一个单一的对象。它定义在头文件 `<utility>` 中，常用于需要返回多个值或存储键值对的场景。

## 关于 std::pair 占用内存大小

`std::pair` 的内存大小取决于其包含的两个数据项的类型及其对齐方式。通常情况下，`std::pair<T1, T2>` 的大小至少是 `sizeof(T1) + sizeof(T2)`，但由于对齐要求，实际大小可能会更大。

例如，考虑以下代码：

```cpp
#include <iostream>
#include <utility>
#include <type_traits>

int main() {
    using PairType = std::pair<int, double>;
    std::cout << "Size of std::pair<int, double>: " << sizeof(PairType) << " bytes" << std::endl;

    // 检查对齐方式
    std::cout << "Alignment of int: " << alignof(int) << std::endl;
    std::cout << "Alignment of double: " << alignof(double) << std::endl;
    std::cout << "Alignment of std::pair<int, double>: " << alignof(PairType) << std::endl;

    return 0;
}
```

输出：
```
Size of std::pair<int, double>: 16 bytes
Alignment of int: 4
Alignment of double: 8
Alignment of std::pair<int, double>: 8
```

在这个例子中，`std::pair<int, double>` 的大小是 16 字节，而不是简单的 12 字节（4 字节的 `int` 加上 8 字节的 `double`），这是因为 `double` 需要 8 字节对齐，导致编译器在 `int` 后面添加了填充字节以满足对齐要求。

---

## 问题

在工作中需要优化内存使用，而其中一个地方使用到了 `absl::flat_hash_map`。其底层实现使用了 `std::pair` 作为键值对存储结构。在项目的场景中，`absl::flat_hash_map` 需要存储大量的键值对，因此 `std::pair` 的内存占用直接影响了整体内存使用效率。

为了优化内存使用，需要将 `value` 类型改为 `uint32_t`，而 `key` 保持使用 `uint64_t` 类型，从而使用 `std::pair<uint64_t, uint32_t>`。理论上，这样可以将 `std::pair` 的大小减少到 12 字节（8 字节的 `uint64_t` 加上 4 字节的 `uint32_t`），但由于对齐要求，实际大小可能会是 16 字节。

所以需要针对这个场景，对 `std::pair<uint64_t, uint32_t>` 这个具体的类型做偏特化，通过重新实现 `std::pair`，将其内存大小优化到 12 字节，从而提升 `absl::flat_hash_map` 的内存使用效率。

---

## 解决方案

通过对 `std::pair` 进行偏特化，实现一个专门针对 `std::pair<uint64_t, uint32_t>` 的版本，确保其内存大小为 12 字节。具体实现如下：

```cpp
#include <utility>
#include "absl/container/flat_hash_map.h"
#pragma pack(4)
namespace std {
template <>
struct pair<const uint64_t, uint32_t> {
    uint64_t first;
    uint32_t second;

    pair() : first(0), second(0) {}
    pair(const uint64_t& a, const uint32_t& b) : first(a), second(b) {}

  template <class... _Args1, class... _Args2>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20
  pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args, tuple<_Args2...> __second_args) noexcept(
      is_nothrow_constructible<first_type, _Args1...>::value && is_nothrow_constructible<second_type, _Args2...>::value)
      : pair(__pc,
             __first_args,
             __second_args,
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2) >::type()) {}

  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20
  pair(piecewise_construct_t,
       tuple<_Args1...>& __first_args,
       tuple<_Args2...>& __second_args,
       __tuple_indices<_I1...>,
       __tuple_indices<_I2...>)
      : first(std::forward<_Args1>(std::get<_I1>(__first_args))...),
        second(std::forward<_Args2>(std::get<_I2>(__second_args))...) {}
};

} // namespace std

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace container_internal {
template <>
union map_slot_type<uint64_t, uint32_t> {
    map_slot_type() {}
    ~map_slot_type() = delete;
    using value_type = std::pair<const uint64_t, uint32_t>;
    using mutable_value_type = std::pair<absl::remove_const_t<uint64_t>, absl::remove_const_t<uint32_t>>;
    value_type value;
    mutable_value_type mutable_value;
    absl::remove_const_t<uint64_t> key;
};
}
ABSL_NAMESPACE_END
} // namespace absl

#pragma pack()
```

这里是根据 clang++ 编译器的 `std::pair` 实现进行的偏特化。通过使用 `#pragma pack(4)` 指令，强制编译器以 4 字节对齐方式存储 `std::pair<uint64_t, uint32_t>`，从而避免了默认的对齐填充。

通过这种方式，可以确保 `std::pair<uint64_t, uint32_t>` 的内存大小为 12 字节，从而优化 `absl::flat_hash_map` 的内存使用效率。

在实际压测中，`hashmap` 的速度没有明显下降，同时内存使用得到了显著优化。

---